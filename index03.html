<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Plan des sondes + Ev√©nements</title>

<!-- ‚úÖ Police compatible accents (latin-ext) -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap&subset=latin-ext" rel="stylesheet">


<style>
:root{
  /* Th√®me (identique viewer02) */
  --bg:#fff5f5; --panel:#ffffff; --accent:#ff7043; --accent-darker:#e64a19;
  --accent-muted:#ffccbc; --danger:#d84315; --text:#333;

--text-light: #fff;
--text-dark: #222;

  
  /* Grille logique */
  --cols: 22;
  --rows-top: 6;
  --rows-bot: 6;
  --split-gap: 0.3;          /* espace vertical entre les 2 sous-grilles (en fraction de case) */

  /* Cellules */
  --tile-size: 110px;        /* sera recalcul√© en JS */
  --cell-gap: 8px;

  /* Sidebar temporelle (en dessous) */
  --timebar-cols: 6;         /* largeur = 6 cases */
}

*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:"Inter",system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",
               Arial,"Noto Sans","Liberation Sans","DejaVu Sans",sans-serif;
  background:var(--bg); color:var(--text);
  min-height:100vh; display:flex; flex-direction:column;
}


/* ===== Header (style viewer02) ===== */
.header{
  position:relative; display:flex; align-items:center; justify-content:center;
  min-height:60px; padding:10px 16px 0;
}
.header .logo{height:50px;width:auto;}
#currentFolderName{
  position:absolute; left:16px; top:8px; font-size:22px; font-weight:bold; color:var(--accent);
  max-width:45vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
#fileNameContainer{position:absolute; right:16px; top:8px; text-align:right;}
#fileName{font-size:18px; font-weight:bold; color:var(--accent-darker); max-width:40vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
#lineCount{font-size:12px; color:var(--accent-darker); margin-top:2px;}
.flame{display:inline-block; animation:flicker 1s infinite alternate;}
@keyframes flicker{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}

/* ===== Titre date/heure ===== */
#datetimeLabel{
  font-weight:bold; font-size:18px; text-align:center; color:var(--danger);
  margin:8px auto 6px;
}

/* ===== PAGE LAYOUT : main (3/4) + side (1/4) ===== */
#pageWrap{
  flex:1; display:flex; gap:10px; padding:10px 12px; overflow:hidden;
}

/* ===== Zone centrale : deux sous-grilles 22√ó6 centr√©es ===== */
#mainCol{
  flex:3; min-width:0;
  display:flex; flex-direction:column;
  overflow:hidden;
  background: transparent;
  min-height:70vh; /* ‚úÖ assure un espace suffisant pour la grille */
}

#gridWrap{
  flex:1; display:flex; align-items:center; justify-content:center;
  overflow:auto;
}
#grid{
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap: calc(var(--tile-size) * var(--split-gap)); /* espace vertical entre top/bottom */
}

/* Sous-grilles 22 colonnes chacune */
.grid-part{
  display:grid;
  grid-template-columns: repeat(var(--cols), var(--tile-size));
  grid-auto-rows: var(--tile-size);
  gap: var(--cell-gap);
}

/* Cellules ‚Äúsonde‚Äù */
.sonde{
  width: var(--tile-size); height: var(--tile-size);
  background: var(--panel); border-radius: 10px;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  box-shadow:0 2px 5px rgba(0,0,0,0.2); padding:6px;
  overflow:hidden;
}
.sonde .label{ font-size: clamp(10px, calc(var(--tile-size)*0.12), 14px); font-weight:bold; color:#000; margin-bottom:2px; }
.sonde .consigne{ font-size: clamp(9px, calc(var(--tile-size)*0.10), 12px); color:#555; font-style:italic; }
.sonde .val{ font-size: clamp(14px, calc(var(--tile-size)*0.18), 22px); font-weight:bold; color:#000; }

/* ===== Cases sp√©ciales ===== */
.sonde.special {
  outline: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;   /* centre verticalement */
  text-align: center;        /* centre horizontalement */
  padding: 0;                /* enl√®ve les d√©calages internes */
}

/* ===== Sidebar temporelle (en dessous de la grille) ===== */
#bottomBar{
  display:flex; align-items:center; justify-content:center; gap:16px;
  padding:10px 0 14px;
}
#timeBar{
  width: calc(var(--timebar-cols) * var(--tile-size) + (var(--timebar-cols) - 1) * var(--cell-gap));
  display:flex; align-items:center; justify-content:center;
}
#slider{ width:100%; height: calc(var(--tile-size) * 0.35); }

#scaleBox{
  background:var(--panel); border:1px solid #ddd; border-radius:8px;
  padding:8px 10px; box-shadow:0 2px 8px rgba(0,0,0,0.12); font-size:13px; color:var(--text);
}
#scaleBox label{ margin-right:6px; }
#scaleBox input{ width:70px; padding:4px; border:1px solid #ccc; border-radius:6px; }

/* Scrollbars (grille) */
#gridWrap::-webkit-scrollbar{height:10px;width:10px;}
#gridWrap::-webkit-scrollbar-thumb{background:var(--accent);border-radius:10px;}
#gridWrap::-webkit-scrollbar-track{background:#eee;}

/* ===== √âv√©nements Z3 (volet √©largi + scrollbar + nuance centr√©e) ===== */
#sideCol {
  flex: 0 1 auto;             /* largeur s‚Äôadapte au contenu */
  min-width: 360px;
  max-width: 600px;           /* largeur max pour les longs textes */
  display: flex;
  flex-direction: column;
  background: var(--panel);
  border-radius: 10px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.15);
  max-height: calc(100vh - 160px);
  overflow: hidden;
  align-self: flex-start;
  margin-bottom: 10px;
}


#sideHeader {
  font-weight: 600;
  font-size: 15px;
  padding: 10px;
  background: var(--accent);
  color: #fff;
  text-align: center;
  border-bottom: 2px solid var(--accent-darker);
}

#z3List {
  flex: 1;
  overflow-y: auto; /* ‚úÖ scroll si trop d‚Äô√©v√©nements */
  background: var(--panel);
  padding: 8px 10px;
  font-family: "Inter", system-ui, sans-serif;
}

/* Items */
.z3Item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  margin-bottom: 4px;
  border-radius: 6px;
  font-size: 13px;
  line-height: 1.2;
  cursor: pointer;
  transition: background 0.25s, color 0.25s, transform 0.15s;
}
.z3Item .t {
  font-family: ui-monospace, Menlo, Consolas, monospace;
  font-size: 12px;
  color: var(--accent-darker);
  min-width: 52px;
}
.z3Item .d {
  flex: 1;
  color: var(--text);
  overflow-wrap: anywhere;
  white-space: normal;
}



/* D√©grad√© centr√© sur l‚Äô√©v√©nement (0 ‚Üí 4) + texte adaptatif */
.z3Item[data-intensity="0"],
.hour-mark[data-intensity="0"] {
  background-color: color-mix(in srgb, var(--accent) 5%, var(--panel));
  color: var(--text-dark);
}

.z3Item[data-intensity="1"],
.hour-mark[data-intensity="1"],
.z3Item[data-intensity="2"],
.hour-mark[data-intensity="2"],
.z3Item[data-intensity="3"],
.hour-mark[data-intensity="3"],
.z3Item[data-intensity="4"],
.hour-mark[data-intensity="4"] {
  /* d√®s qu‚Äôil y a de la couleur, texte blanc */
  color: var(--text-light);
}

.z3Item[data-intensity="1"],
.hour-mark[data-intensity="1"] {
  background-color: color-mix(in srgb, var(--accent) 25%, var(--panel));
}

.z3Item[data-intensity="2"],
.hour-mark[data-intensity="2"] {
  background-color: color-mix(in srgb, var(--accent) 45%, var(--panel));
}

.z3Item[data-intensity="3"],
.hour-mark[data-intensity="3"] {
  background-color: color-mix(in srgb, var(--accent) 65%, var(--panel));
}

.z3Item[data-intensity="4"],
.hour-mark[data-intensity="4"] {
  background-color: var(--accent-darker);
  transform: scale(1.02);
}



/* Lissage des transitions de couleur et lisibilit√© */
.z3Item {
  transition: background-color 0.4s ease, color 0.3s ease, transform 0.15s ease;
}

/* Lignes horaires (rep√®res visuels) */
.hour-mark {
  opacity: 0.6;
  font-style: italic;
  background: var(--panel);
  color: var(--accent-darker);
  cursor: default;
}


/* √âv√©nement s√©lectionn√© */
.z3Item.active {
  outline: 2px solid var(--accent);
  background: var(--accent-muted);
  color: var(--accent-darker);
}

/* Scrollbar esth√©tique */
#z3List::-webkit-scrollbar { width: 8px; }
#z3List::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 6px; }
#z3List::-webkit-scrollbar-track { background: var(--accent-muted); }



/* collapsed state (rail) */
#sideCol.collapsed{
  min-width: 46px; max-width: 46px;
}
#sideCol.collapsed #sideHeader h3,
#sideCol.collapsed .sideSection { display:none; }
#sideCol.collapsed #toggleSide{ width:100%; border-radius:8px; }

/* small hint button floating (optional, not needed since header has toggle) */
#floatOpen{
  position:absolute; left:-8px; top:12px;
  transform: translateX(-100%);
  background: var(--accent); color:#fff; border:none; border-radius:14px;
  padding:6px 8px; cursor:pointer; display:none;
}
#floatOpen:hover{ background: var(--accent-darker); }

/* üîß Correctif final : texte blanc d√®s qu‚Äôune intensit√© colore la case */
.z3Item[data-intensity]:not([data-intensity="0"]),
.hour-mark[data-intensity]:not([data-intensity="0"]) {
  color: var(--text-light) !important;
}

.z3Item[data-intensity]:not([data-intensity="0"]) .t,
.z3Item[data-intensity]:not([data-intensity="0"]) .d,
.hour-mark[data-intensity]:not([data-intensity="0"]) .t,
.hour-mark[data-intensity]:not([data-intensity="0"]) .d {
  color: var(--text-light) !important;
}

/* Et un petit contraste pour le texte neutre (intensit√© 0) */
.z3Item[data-intensity="0"] .t,
.z3Item[data-intensity="0"] .d,
.hour-mark[data-intensity="0"] .t,
.hour-mark[data-intensity="0"] .d {
  color: var(--text-dark) !important;
}

  
</style>
</head>
<body>

<!-- ===== Header ===== -->
<div class="header">
  <div id="currentFolderName"></div>
  <img src="img/logo.png" class="logo" alt="Logo"/>
  <div id="fileNameContainer">
    <div id="fileName"></div>
    <div id="lineCount"></div>
  </div>
</div>

<div id="datetimeLabel">-- / -- / ---- ‚Äî --:--</div>

<!-- ===== PAGE WRAP (main + side) ===== -->
<div id="pageWrap">

  <!-- ===== MAIN (inchang√© dans l‚Äôesprit) ===== -->
  <div id="mainCol">
    <div id="gridWrap">
      <div id="grid">
        <div id="gridTop" class="grid-part"></div>
        <div id="gridBottom" class="grid-part"></div>
      </div>
    </div>

    <!-- ===== Sidebar temporelle + min/max ===== -->
    <div id="bottomBar">
      <div id="timeBar">
        <input type="range" id="slider" min="0" max="0" value="0"/>
      </div>
      <div id="scaleBox" title="R√©glage des bornes couleurs">
        <label>Min</label><input type="number" id="minInput" step="0.1" value="30"/>
        <label style="margin-left:10px;">Max</label><input type="number" id="maxInput" step="0.1" value="60"/>
      </div>
      <!-- Bouton optionnel plus tard : Fusion jours (d√©sactiv√© par d√©faut) -->
      <!-- <button id="mergeDaysBtn" style="margin-left:12px;">Fusionner jours</button> -->
    </div>
  </div>

  <!-- ===== SIDE (Z3 EVENTS) ===== -->
<aside id="sideCol">
  <div id="sideHeader">üß∞ Evenements</div>
  <div id="z3List"></div>
</aside>


    
</div>

<script src="libs/papaparse.min.js"></script>
<script>




/* =================== Globals =================== */
let csvData=[], headers=[], planTop=[], planBottom=[];
let z3Events = [];         // {timeText, minutes, desc, fileId, fileName}
let lastSliderIndex = 0;
let currentDay = null;
let isMerging = false;
let mergedDays = new Set();
const Z3_HILITE_TOL_MIN = 5;  // tol√©rance (minutes) pour surlignage
const params=new URLSearchParams(window.location.search);
const fileId=params.get("fileId");
const fileName=params.get("fileName");

/* =================== Header dossier + flamme =================== */
(function hydrateFolderHeader(){
  let title="";
  try{
    const list = JSON.parse(localStorage.getItem("csvFilesList")||"[]");
    const f = list.find(x=>x.id===fileId);
    if(f && f.parents && f.parents.length){
      const parent = list.find(x=>x.id===f.parents[0]);
      if(parent && parent.name){
        title = parent.name;
        if(parent.parents && parent.parents.length){
          const root = list.find(x=>x.id===parent.parents[0]);
          if(root && root.name) title = root.name+" / "+parent.name;
        }
      }
    }
  }catch(e){}
  if(!title) title = decodeURIComponent(fileName||"");
  const flameTitle = title.replace(/üî•/g,'<span class="flame" title="Br√ªleur(s) en fonctionnement">üî•</span>');
  const el=document.getElementById("currentFolderName");
  if(el) el.innerHTML=flameTitle;
  const fn=document.getElementById("fileName");
  if(fn) fn.textContent = decodeURIComponent(fileName||"");
})();

/* =================== Plan depuis localStorage =================== */
function loadPlan(){
  const raw=localStorage.getItem("planSondes");
  if(!raw){
    document.getElementById("gridTop").innerHTML="<b style='color:red'>‚ùå planSondes manquant</b>";
    return;
  }
  const lines = raw.trim().split(/\r?\n/).map(l=>{
    const cols = l.split(",").map(v=>v.trim());
    return cols.every(v=>v==="") ? null : cols;
  });

  // scinder en deux blocs (ligne vide = s√©paration)
  let top=[], bottom=[], buf=[];
  let topDone=false;
  for(const row of lines){
    if(row===null){ if(!topDone){ top = buf; topDone=true; buf=[]; } else { /* ignore extra splits */ } }
    else buf.push(row);
  }
  bottom = topDone ? buf : [];

  planTop = top;
  planBottom = bottom;

  buildGrid();
}

/* =================== Construction de la grille centr√©e =================== */
function buildGrid(){
  const gridTop = document.getElementById("gridTop");
  const gridBottom = document.getElementById("gridBottom");
  gridTop.innerHTML = ""; 
  gridBottom.innerHTML = "";

  const cols = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cols')) || 22;

  function placeRows(container, rows){
    if(!rows || !rows.length) return;
    const planCols = rows[0].length;
    const startCol = Math.max(1, Math.floor((cols - planCols)/2) + 1); // centre dans 22
    rows.forEach(r=>{
      r.forEach((num, j)=>{
        if(!num) return;
        const d=document.createElement("div");
        d.className="sonde";
        d.id="sonde"+num;
        d.style.gridColumn = (startCol + j) + " / span 1";
        d.innerHTML = `
          <div class="label">Sonde ${num}</div>
          <div class="consigne">-- ¬∞C</div>
          <div class="val">-- ¬∞C</div>`;
        container.appendChild(d);
      });
    });
  }

  placeRows(gridTop, planTop);
  placeRows(gridBottom, planBottom);
} // üîπ Fin de buildGrid()

/* ============ RIGHT PANEL: load + render Z3 (auto-fetch if missing content) ============ */
function yyyymmddFromName(name){
  const m = (name||"").match(/(\d{8})/);
  return m ? m[1] : null;
}

function toMinutes(t){
  if(!t) return NaN;
  const m = String(t).trim().match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if(!m) return NaN;
  const hh = parseInt(m[1],10), mm = parseInt(m[2],10), ss = parseInt(m[3]||"0",10);
  return hh*60 + mm + (ss>=30? 0.5:0);
}

function minutesFromRowTime(row){
  const timeKey=headers.find(h=>{
    const a=(h||"").toLowerCase();
    return a.includes("heure")||a.includes("time")||a==="h";
  });
  const t = timeKey ? String(row[timeKey]||"").trim() : "";
  return toMinutes(t);
}

function currentRowMinutes(idx){
  if(!csvData[idx]) return NaN;
  return minutesFromRowTime(csvData[idx]);
}

/* =====================================================
   üîÅ Synchronisation automatique des fichiers Z3
   - V√©rifie que le cache est charg√© depuis index.html
   - Recharge si besoin √† partir du dossier "Historique"
   ===================================================== */
async function ensureZ3FilesLoaded() {
  const cached = JSON.parse(localStorage.getItem("csvZ3Files") || "[]");
  if (cached.length) {
    console.log(`üì¶ ${cached.length} fichiers Z3 d√©j√† pr√©sents dans le cache`);
    return cached;
  }

  console.warn("‚ö†Ô∏è Aucun Z3 pr√©charg√© trouv√©, tentative de rechargement‚Ä¶");

  try {
    const list = JSON.parse(localStorage.getItem("csvFilesList") || "[]");
    const first = list.find(
      f => f.name &&
      (f.name.toLowerCase().includes("tra√ßa_temp") || f.name.toLowerCase().includes("traca_temp"))
    );
    if (!first) throw new Error("Pas de dossier Tra√ßa_Temp d√©tect√©");

    const parentFolder = first.folder.split('/').slice(0, -1).join('/');
    const historiqueFolder = `${parentFolder}/Historique`;

    const res = await fetch(`/api/list?path=${encodeURIComponent(historiqueFolder)}`);
    if (!res.ok) throw new Error("Erreur de lecture API");
    const files = await res.json();

    const z3Files = files
      .filter(f => f.name.startsWith("Z3") && f.name.endsWith(".csv"))
      .map(f => ({
        name: f.name,
        path: `${historiqueFolder}/${f.name}`,
        folder: historiqueFolder
      }));

    localStorage.setItem("csvZ3Files", JSON.stringify(z3Files));
    console.log(`‚úÖ ${z3Files.length} fichiers Z3 recharg√©s depuis "${historiqueFolder}"`);
    return z3Files;
  } catch (err) {
    console.error("‚ùå Impossible de recharger les fichiers Z3 :", err);
    return [];
  }
}

  
// =====================================================
// ‚úÖ Version identique √† viewer02 ‚Äî compl√®te et robuste
// =====================================================
// =====================================================
// ‚úÖ Version identique √† viewer02 ‚Äî compl√®te et robuste
// =====================================================
async function loadZ3ForSameDay() {
  z3Events = [];

  const dayMatch = (fileName || "").match(/(\d{8})/);
  const day = dayMatch ? dayMatch[1] : null;
  if (!day) {
    console.warn("‚ö†Ô∏è Impossible de d√©tecter la date du fichier principal :", fileName);
    renderZ3List();
    return;
  }

  // üîπ R√©cup√©ration ou rechargement des fichiers Z3
  const z3Files = await ensureZ3FilesLoaded();
  const sameDay = z3Files.filter(f => f.name.includes(day));
  console.log(`üîç Recherche Z3 du ${day} ‚Üí ${sameDay.length} fichier(s) trouv√©(s)`);

  for (const f of sameDay) {
    let text = f.content;

    // üî∏ Si pas de contenu, t√©l√©chargement via proxy Drive (identique viewer02)
    if (!text && f.id) {
      try {
        console.log("üåê T√©l√©chargement Z3 depuis Drive :", f.name);
        const url = `https://smes21540.netlify.app/.netlify/functions/drive?id=${f.id}&name=${encodeURIComponent(f.name || "")}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("Erreur proxy Drive");
        const buf = await res.arrayBuffer();
        text = decodeSmart(buf); // m√™me d√©codage que CSV principal

        f.content = text;
        const all = JSON.parse(localStorage.getItem("csvZ3Files") || "[]");
        const updated = all.map(x => x.name === f.name ? f : x);
        localStorage.setItem("csvZ3Files", JSON.stringify(updated));
      } catch (err) {
        console.error("‚ùå Erreur chargement fichier Z3 :", f.name, err);
        continue;
      }
    }

    if (!text) continue;

    // üßπ Nettoyage et parsing CSV
    const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
    let startIndex = lines.findIndex(l => /trigger.?time|horodatage/i.test(l));
    if (startIndex === -1) startIndex = 0;
    const csvClean = lines.slice(startIndex).join("\n");

    const parsed = Papa.parse(csvClean, {
      header: true,
      skipEmptyLines: true,
      dynamicTyping: false,
      delimitersToGuess: [",", ";", "\t"],
    });

    const H = parsed.meta.fields || [];
    const rows = parsed.data || [];

    // üîç D√©tection des colonnes (FR / EN / variantes)
    const timeCol = H.find(h => /(trigger.?time|heure|horodatage|time|temps)/i.test(h)) || H[0];
    const msgCol  = H.find(h => /(message|desc|description|evenement|event)/i.test(h)) || H[1];
    const addrCol = H.find(h => /(address|adresse|addr|zone|address ?1)/i.test(h)) || null;

    console.log("üß© Colonnes Z3 d√©tect√©es :", { timeCol, msgCol, addrCol });

    for (const r of rows) {
      const t = String(r[timeCol] || "").trim();
      const msg = String(r[msgCol] || "").trim();
      const addr = String(r[addrCol] || "").trim();
      const mins = toMinutes(t);
      if (!isNaN(mins) && msg) {
        z3Events.push({
          timeText: t,
          minutes: mins,
          desc: addr ? `${msg} (${addr})` : msg,
          fileId: f.id,
          fileName: f.name,
        });
      }
    }
  }

console.log("‚úÖ Total √©v√©nements Z3 charg√©s :", z3Events.length);

// ‚úÖ Aligne l'ordre logique : DOM des √©v√©nements <-> z3Events
z3Events.sort((a, b) => a.minutes - b.minutes);

renderZ3List();
highlightZ3Near(currentRowMinutes(0));

}
function updateZ3Intensity(currentMinutes) {
  const RANGE = 15;          // influence ¬±15 min autour
  const MAX_INTENSITY = 4;   // 0‚Üí4 correspond aux niveaux CSS

  const allItems = Array.from(document.querySelectorAll("#z3List .z3Item, #z3List .hour-mark"));
  if (!allItems.length) return;

  allItems.forEach(el => {
    let minutes;
    if (el.classList.contains("hour-mark")) {
      minutes = toMinutes(el.querySelector(".t")?.textContent);
    } else {
      const idx = parseInt(el.dataset.evIndex || "-1");
      minutes = z3Events[idx]?.minutes ?? NaN;
    }

    if (isNaN(minutes)) {
      el.dataset.intensity = 0;
      return;
    }

    const diff = Math.abs(minutes - currentMinutes);
    const ratio = 1 - Math.min(diff / RANGE, 1);
    const level = Math.round(ratio * MAX_INTENSITY);
    el.dataset.intensity = level;
  });
  allItems.forEach(el => {
    let minutes;
    if (el.classList.contains("hour-mark")) {
      minutes = toMinutes(el.querySelector(".t")?.textContent);
    } else {
      const idx = parseInt(el.dataset.evIndex || "-1");
      minutes = z3Events[idx]?.minutes ?? NaN;
    }

    if (isNaN(minutes)) {
      el.dataset.intensity = 0;
      return;
    }

    const diff = Math.abs(minutes - currentMinutes);
    const ratio = 1 - Math.min(diff / RANGE, 1);
    const level = Math.round(ratio * MAX_INTENSITY);
    el.dataset.intensity = level;
  });

  // üîπ Lisibilit√© dynamique : texte clair sur fond sombre
  allItems.forEach(el => {
    const style = getComputedStyle(el);
    const bg = style.backgroundColor;

    // Convertit la couleur en luminance relative (perceptuelle)
    const rgb = bg.match(/\d+/g)?.map(Number) || [255,255,255];
    const luminance = (0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]) / 255;

    // D√©termine couleur texte : clair si fond sombre
    el.style.color = luminance < 0.5 ? "var(--text-light)" : "var(--text-dark)";
  });
}












// üîÅ Version align√©e : z3Events tri√© + rep√®res 15 min intercal√©s
function renderZ3List() {
  const box = document.getElementById("z3List");
  box.innerHTML = "";

  if (!z3Events.length) {
    box.innerHTML = `<div class="z3Item" style="opacity:.7;cursor:default;">
      <span class="t">--:--</span><span class="d">Aucun √©v√©nement Z3</span>
    </div>`;
    return;
  }

  // Rep√®res horaires 00:00 ‚Üí 23:45 (toutes les 15 min)
  const timeMarks = [];
  for (let h = 0; h < 24; h++) {
    for (let q = 0; q < 60; q += 15) {
      const hh = String(h).padStart(2, "0");
      const mm = String(q).padStart(2, "0");
      timeMarks.push(`${hh}:${mm}`);
    }
  }

  // z3Events est D√âJ√Ä TRI√â par minutes
  let evIdx = 0;

  for (const mark of timeMarks) {
    const markMin = toMinutes(mark);

    // Ligne de rep√®re
    const markDiv = document.createElement("div");
    markDiv.className = "z3Item hour-mark";
    markDiv.innerHTML = `<span class="t">${mark}</span><span class="d"></span>`;
    box.appendChild(markDiv);

    // Ajoute tous les √©v√©nements qui tombent dans ce quart d'heure
    while (evIdx < z3Events.length && z3Events[evIdx].minutes < markMin + 15) {
      const ev = z3Events[evIdx];
      const div = document.createElement("div");
      div.className = "z3Item";
      // stocke l‚Äôindex logique de l‚Äô√©v√©nement (optionnel mais utile)
      div.dataset.evIndex = String(evIdx);
      div.innerHTML = `<span class="t">${ev.timeText}</span><span class="d">${ev.desc}</span>`;
      div.onclick = () => jumpSliderToClosest(ev.minutes);
      box.appendChild(div);
      evIdx++;
    }

    if (evIdx >= z3Events.length) break; // plus d'√©v√©nements : on peut s‚Äôarr√™ter t√¥t
  }
}




function highlightZ3Near(targetMinutes) {
  // Nettoie tout
  document.querySelectorAll("#z3List .z3Item").forEach(el => el.classList.remove("active"));
  if (isNaN(targetMinutes) || !z3Events.length) return;

  // Trouve l‚Äôindex de l‚Äô√©v√©nement le plus proche
  let bestIdx = -1, bestDiff = Infinity;
  z3Events.forEach((ev, idx) => {
    const diff = Math.abs(ev.minutes - targetMinutes);
    if (diff < bestDiff) { bestDiff = diff; bestIdx = idx; }
  });

  // Tol√©rance
  if (bestIdx === -1 || bestDiff > Z3_HILITE_TOL_MIN) return;

  // R√©cup√®re la N-i√®me tuile √©v√©nement (en ignorant les rep√®res)
  const eventItems = Array.from(document.querySelectorAll("#z3List .z3Item"))
    .filter(el => !el.classList.contains("hour-mark"));

  const el = eventItems[bestIdx];
  if (el) {
    el.classList.add("active");

    // Scroll dans la vue si besoin
    const box = document.getElementById("z3List");
    const boxRect = box.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    if (elRect.top < boxRect.top || elRect.bottom > boxRect.bottom) {
      box.scrollTop = el.offsetTop - box.clientHeight / 2 + el.clientHeight / 2;
    }
  }
} // ‚úÖ cette accolade ferme bien la fonction enti√®re







function jumpSliderToClosest(targetMinutes){
  if(!csvData.length) return;
  let bestIdx = 0, bestDiff = Infinity;
  for(let i=0;i<csvData.length;i++){
    const mins = minutesFromRowTime(csvData[i]);
    if(isNaN(mins)) continue;
    const diff = Math.abs(mins - targetMinutes);
    if(diff < bestDiff){ bestDiff = diff; bestIdx = i; }
  }
  const slider = document.getElementById("slider");
  slider.value = String(bestIdx);
  lastSliderIndex = bestIdx;
  updateGrid(bestIdx);
  highlightZ3Near(currentRowMinutes(bestIdx));
}

/* ============ Ajout diff√©r√© des cases sp√©ciales (inchang√© sauf position) ============ */
function addSpecialsAfterCSV() {
  const normalize = s => (s || "").normalize("NFD").replace(/[^\w]/g, "").toLowerCase();

  // D√©tection ultra tol√©rante
  const hasExt   = headers.some(h => normalize(h).includes("tcext") || normalize(h).includes("temperatureexterieure") || normalize(h).includes("tempext"));
  const hasDebit = headers.some(h => normalize(h).includes("debit") || normalize(h).includes("debitth") || normalize(h).includes("dbit") || normalize(h).includes("tonne"));
  const hasGaz   = headers.some(h => normalize(h).includes("gaz"));
  const hasNorm  = headers.some(h => normalize(h).includes("normalis"));
  const hasIpe   = headers.some(h => normalize(h).includes("ipe") || normalize(h).includes("ip") || normalize(h).includes("ipekwh"));

  const specials = [
    // üî∏ Sondes internes
    { id: "SondeACsup", label: "Air chaud Sup√©rieur", col: "G", row: 4 },
    { id: "SondeACinf", label: "Air chaud Inf√©rieur", col: "G", row: 10 },
    { id: "TempGrain",  label: "Temp√©rature Grain",   col: "P", row: 7 },
    { id: "TempExt",    label: "Temp√©rature Ext√©rieure üå°Ô∏è", col: "E", row: 10, optional: true, active: hasExt },

    // üî∏ Nouvelles cases de suivi
    { id: "DebitTH",   label: "D√©bit S√©chage", col: "D", row: 7, optional: true, bg: "#00CCFF", active: hasDebit },
    { id: "GazM3H",    label: "üî• GAZ",        col: "D", row: 8, optional: true, bg: "#FFCC33", active: hasGaz },
    { id: "Normalise", label: "üî• GAZ",        col: "D", row: 9, optional: true, bg: "#FFCC33", active: hasNorm },
    { id: "IPE",       label: "üî• Ip√©",        col: "D", row:10, optional: true, bg: "#33FF00", active: hasIpe }
  ];

  // üî∏ Nouveaux compteurs et chronos
  const hasMinuterie  = headers.some(h => normalize(h).includes("minuterie"));
  const hasModulee    = headers.some(h => normalize(h).includes("modulee"));
  const hasCumul      = headers.some(h => normalize(h).includes("cumul"));
  const hasExtract    = headers.some(h => normalize(h).includes("extraction"));
  const hasCptTotal   = headers.some(h => normalize(h).includes("cptkwh") && normalize(h).includes("total"));
  const hasCptLot     = headers.some(h => normalize(h).includes("cptkwh") && normalize(h).includes("lot"));

  specials.push(
    { id: "Minuterie", label: "Minuterie", col: "R", row: 7, optional: true, active: hasMinuterie, unit: "s", bg: "#ccffcc" },   // vert clair
    { id: "Modulee",   label: "Modul√©e",   col: "R", row: 8, optional: true, active: hasModulee,   unit: "s", bg: "#cce5ff" },   // bleu clair
    { id: "Cumul",     label: "Cumul",     col: "R", row: 9, optional: true, active: hasCumul,     unit: "t", bg: "#ccffcc" },   // vert clair
    { id: "NbExtract", label: "Nb Extraction", col: "R", row: 10, optional: true, active: hasExtract, bg: "#ccffcc" },            // vert clair
    { id: "CptTotal",  label: "Compteur kWh Total", col: "B", row: 8, optional: true, active: hasCptTotal, unit: "kWh", bg: "#FFCC33" }, // jaune gaz
    { id: "CptLot",    label: "Compteur kWh Lot", col: "B", row: 9, optional: true, active: hasCptLot, unit: "kWh", bg: "#FFCC33" }     // jaune gaz
  );


  
  function colIdx(letter){ return letter.toUpperCase().charCodeAt(0) - 64; }

  function placeSpecial(s){
    const col = colIdx(s.col);
    const row = s.row;
    const d = document.createElement("div");
    d.className = "sonde special";
    d.id = s.id;
    if (s.bg) d.style.background = s.bg;
    d.innerHTML = `
      <div class="label">${s.label}</div>
      <div class="consigne">--</div>
      <div class="val">--</div>`;
    const target = (row <= 6) ? document.getElementById("gridTop") : document.getElementById("gridBottom");
    d.style.gridColumn = `${col} / span 1`;
    d.style.gridRow = `${row <= 6 ? row : row - 6} / span 1`;
    target.appendChild(d);
  }

  specials.forEach(s => { if (!s.optional || s.active) placeSpecial(s); });
}

/* =================== Responsive : calcule la taille de case =================== */
function updateTileSize(){
  const wrap = document.getElementById("gridWrap");
  const cols = 22;
  const rows = 12;
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap'))||8;
  const splitGapRatio = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--split-gap'))||0.3;

  const availW = wrap.clientWidth - 32;   // marges internes
  const availH = wrap.clientHeight - 16;

  const totalVCellGaps = (6-1) + (6-1); // 10
  const hByW = (availW - (cols-1)*gap) / cols;
  const hByH = (availH - totalVCellGaps*gap) / (rows + splitGapRatio); 
  const s = Math.max(60, Math.floor(Math.min(hByW, hByH))); // taille min 60px

  document.documentElement.style.setProperty('--tile-size', s + 'px');
}

/* =================== CSV (Drive ou LocalStorage) =================== */
// === Helper encodage intelligent ===
function decodeSmart(arrayBuffer) {
  let txt = new TextDecoder("utf-8", { fatal: false }).decode(arrayBuffer);
  if (txt.includes("√É") || txt.includes("√Ç") || txt.includes("ÔøΩ")) {
    try {
      txt = new TextDecoder("iso-8859-1").decode(arrayBuffer);
    } catch (e) {
      console.warn("Erreur de d√©codage ISO-8859-1", e);
    }
  }
  return txt;
}


  
  async function loadCSV(){
  const list = JSON.parse(localStorage.getItem("csvFilesList") || "[]");
  const idx = parseInt(localStorage.getItem("csvFileIndex") || "0");
  let file = list.find(f => f.id === fileId) || list[idx] || null;
  let text = "";

  // 1Ô∏è‚É£ Si le CSV est d√©j√† pr√©sent en m√©moire ‚Üí on l'utilise
  if (file && file.content) {
    console.log("üì¶ CSV trouv√© dans localStorage :", file.name);
    text = file.content;
  } 
  // 2Ô∏è‚É£ Sinon, on le t√©l√©charge depuis le proxy Netlify (comme avant)
  else if (file && file.id) {
    const url = `https://smes21540.netlify.app/.netlify/functions/drive?id=${file.id}&name=${encodeURIComponent(file.name || "")}`;
    try {
const res = await fetch(url);
if (!res.ok) throw new Error("Erreur proxy Drive");

// ‚úÖ D√©codage intelligent UTF-8 / ISO-8859-1
const buf = await res.arrayBuffer();
text = decodeSmart(buf);


      
      console.log("üåê CSV t√©l√©charg√© depuis Drive :", file.name);

      // On le sauvegarde dans le localStorage pour la prochaine fois
      const updated = list.map(f => f.id === file.id ? { ...f, content: text } : f);
      localStorage.setItem("csvFilesList", JSON.stringify(updated));
    } catch (err) {
      console.error("‚ùå Erreur chargement CSV :", err);
      document.getElementById("gridTop").innerHTML = `<b style='color:red'>‚ùå Impossible de charger le CSV</b>`;
      return;
    }
  } else {
    console.error("‚ö†Ô∏è Aucun fichier CSV valide trouv√©.");
    document.getElementById("gridTop").innerHTML = `<b style='color:red'>‚ùå Aucun CSV valide trouv√©</b>`;
    return;
  }

  // 3Ô∏è‚É£ Parsing du CSV
  const seen = {};
  const results = Papa.parse(text, {
    header: true,
    skipEmptyLines: true,
    transformHeader: (h) => {
      h = (h || "").replace(/"/g, "").trim();
      if (seen[h]) {
        seen[h]++;
        return h + "_" + seen[h];
      } else {
        seen[h] = 1;
        return h + "_1";
      }
    },
  });

  headers = results.meta.fields || [];
  csvData = results.data || [];
// üóìÔ∏è D√©tecte le jour courant
const m = (file.name || "").match(/(\d{8})/);
currentDay = m ? m[1] : null;
if (currentDay) mergedDays.add(currentDay);

  const lc = document.getElementById("lineCount");
  if (lc)
    lc.textContent =
      (csvData?.length || 0) +
      " ligne" +
      ((csvData?.length || 0) > 1 ? "s" : "");
  document.getElementById("slider").max = Math.max(
    0,
    (csvData.length || 1) - 1
  );

  const minInit = parseFloat(localStorage.getItem("scaleMin") || "30");
  const maxInit = parseFloat(localStorage.getItem("scaleMax") || "60");
  document.getElementById("minInput").value = isNaN(minInit) ? 30 : minInit;
  document.getElementById("maxInput").value = isNaN(maxInit) ? 60 : maxInit;

  // 4Ô∏è‚É£ Ajout des cases sp√©ciales et affichage initial
  addSpecialsAfterCSV();
  updateGrid(0);

  // 5Ô∏è‚É£ Les fichiers Z3 ‚Üí uniquement depuis localStorage
  loadZ3ForSameDay();
}



/* =================== Couleurs =================== */
function getScale(){
  let min=parseFloat(document.getElementById("minInput").value);
  let max=parseFloat(document.getElementById("maxInput").value);
  if(!isFinite(min)) min=30;
  if(!isFinite(max)) max=60;
  if(max<=min) max=min+1;
  return {min,max};
}
function getColor(v){
  const {min,max}=getScale();
  let t=(v-min)/(max-min); t=Math.max(0,Math.min(1,t));
  if(t<0.5){const r=t/0.5;return `rgb(0,${Math.round(150+105*r)},${Math.round(255-255*r)})`;}
  else if(t<0.75){const r=(t-0.5)/0.25;return `rgb(${Math.round(255*r)},255,0)`;}
  else if(t<0.9){const r=(t-0.75)/0.15;return `rgb(255,${Math.round(255-90*r)},0)`;}
  else{const r=(t-0.9)/0.1;return `rgb(255,${Math.round(165-165*r)},0)`;}
}

/* =================== Actualisation d‚Äôune ligne =================== */
function updateGrid(idx){
  if(!csvData[idx]) return;
  lastSliderIndex = idx;
  const row = csvData[idx];

  // Date/Heure
  const dateKey=headers.find(h=>(h||"").toLowerCase().includes("date"));
  const timeKey=headers.find(h=>{
    const a=(h||"").toLowerCase();
    return a.includes("heure")||a.includes("time")||a==="h";
  });
  let dt=""; 
  if(dateKey&&row[dateKey]) dt+=String(row[dateKey]); 
  if(timeKey&&row[timeKey]) dt+=(dt?" ‚Äî ":"")+String(row[timeKey]);
  document.getElementById("datetimeLabel").textContent = dt||"";

  // === Sondes normales ===
  const allCells = document.querySelectorAll('.sonde:not(.special)');
  allCells.forEach(div=>{
    const n = div.id.replace("sonde","").padStart(2,"0");
    const consCol = "Sonde"+n+"_1";
    const valCol  = "Sonde"+n+"_2";
    const cons = parseFloat(row[consCol]);
    const val  = parseFloat(row[valCol]);
    div.querySelector(".consigne").textContent = isNaN(cons) ? "-- ¬∞C" : cons.toFixed(1)+" ¬∞C";
    const vdiv = div.querySelector(".val");
    if(!isNaN(val)){
      vdiv.textContent=val.toFixed(1)+" ¬∞C"; 
      div.style.background=getColor(val);
    } else {
      vdiv.textContent="-- ¬∞C"; 
      div.style.background="#eee";
    }
  });

  // üî∏ Fonction g√©n√©rique pour les cases sp√©ciales
  function updateSpecial(label, id, opts = {}) {
    const { altLabels = [], prefer = [] } = opts;
    const el = document.getElementById(id);
    if (!el) return;

    const norm = s => (s || "").normalize("NFD").replace(/[^\w]/g, "").toLowerCase();
    const wanted  = [label, ...altLabels].map(norm);
    const prefers = (prefer || []).map(norm);

    // --- Recherche colonne exacte ---
    let valCol = null;
    for (const h of headers) {
      const n = norm(h);
      if (prefers.some(p => n === p || n.includes(p))) { valCol = h; break; }
    }
    if (!valCol) {
      for (const h of headers) {
        const n = norm(h);
        if (wanted.some(w => n.includes(w))) { valCol = h; break; }
      }
    }

    const val = valCol ? parseFloat(row[valCol]) : NaN;

    // --- Unit√©s auto ---
    let unit = "¬∞C";
    const L = norm(label);
    if (L.includes("debit")) unit = "t/h";
    else if (L.includes("gaz") && !L.includes("normal")) unit = "m¬≥/h";
    else if (L.includes("normal")) unit = "Nm¬≥/h";
    else if (L.includes("ip")) unit = "kWh/tee";

// üî∏ Priorit√© √† l‚Äôunit√© personnalis√©e (sp√©ciale)
if (opts.unit) unit = opts.unit;

// üî∏ Format d'affichage selon la nature de la donn√©e
let decimals = 1;
if (["minuterie", "modulee", "nbextract"].some(k => L.includes(k))) {
  decimals = 0; // format entier
  unit = opts.unit || ""; // pas de ¬∞C par d√©faut
} else if (L.includes("cumul")) {
  decimals = 1;
  unit = opts.unit || "t";
}

    // --- Style valeur ---
    const vdiv = el.querySelector(".val");
    vdiv.style.fontSize = "clamp(11px, calc(var(--tile-size)*0.13), 17px)";
    vdiv.textContent = isNaN(val) ? `-- ${unit}` : `${val.toFixed(decimals)} ${unit}`;


    // --- Consignes ACsup/ACinf/Grain (comme avant) ---
    const consEl = el.querySelector(".consigne");
    if (L.includes("acsup") || L.includes("acinf") || L.includes("grain")) {
      let consCol = null, valCol2 = null, count = 0;
      for (const h of headers) {
        const n = norm(h);
        if (n.includes(norm(label))) {
          count++;
          if (count === 1) consCol = h;
          if (count === 2) valCol2 = h;
        }
      }
      const consVal = consCol ? parseFloat(row[consCol]) : NaN;
      const valVal  = valCol2 ? parseFloat(row[valCol2]) : NaN;
      consEl.style.display = "block";
      consEl.textContent = isNaN(consVal) ? "-- ¬∞C" : `${consVal.toFixed(1)} ¬∞C`;
      vdiv.textContent = isNaN(valVal) ? "-- ¬∞C" : `${valVal.toFixed(1)} ¬∞C`;
      if (!isNaN(valVal)) el.style.background = getColor(valVal);
    } else {
      consEl.style.display = "none";
    }
  }

  // üîπ Appels
  updateSpecial("Sonde AC sup", "SondeACsup");
  updateSpecial("Sonde AC inf", "SondeACinf");
  updateSpecial("Temp Grain",    "TempGrain");
  updateSpecial("T¬∞C Ext",       "TempExt", {
    altLabels: ["Temperature Exterieure", "Temp Ext", "TC Ext", "T C Ext"]
  });

  // üîπ Suivis (1 seule colonne)
  updateSpecial("D√©bit", "DebitTH", {
    altLabels: ["D bit t/h", "D√©bit T/H", "D√©bit (Tonnes / Heure)"],
    prefer: ["dbitth"]
  });
  updateSpecial("Gaz", "GazM3H", {
    altLabels: ["Gaz m3/h", "GAZ M3/H", "Consommation (m3 / Heure)"],
    prefer: ["gazm3h"]
  });
  updateSpecial("Normalis√©", "Normalise", {
    altLabels: ["Normalis", "Normalis√©", "Consommation (Nm3 / Heure)"],
    prefer: ["normalis"]
  });
  updateSpecial("Ip√©", "IPE", {
    altLabels: ["Ip", "Ipe", "Ip√© (kWh/tee)", "IPE"],
    prefer: ["ip"]
  });

   // Nouveaux suivis process
  updateSpecial("Minuterie", "Minuterie", { altLabels: ["Minuterie"], prefer: ["minuterie"] });
  updateSpecial("Modul√©e",   "Modulee",   { altLabels: ["Modulee"], prefer: ["modulee"] });
  updateSpecial("Cumul",     "Cumul",     { altLabels: ["Cumul"], prefer: ["cumul"] });
  updateSpecial("Nb Extraction", "NbExtract", { altLabels: ["Extractions"], prefer: ["extraction"] });
  updateSpecial("Compteur kWh Total", "CptTotal", { altLabels: ["CPT KWH TOTAL"], prefer: ["cptkwhtotal"], unit: "kWh" });
  updateSpecial("Compteur kWh Lot", "CptLot", { altLabels: ["CPT KWH LOT"], prefer: ["cptkwhlot"], unit: "kWh" });
 

  // ‚ûï Surligne l'event Z3 le plus proche de l'heure courante
  const mins = minutesFromRowTime(row);
  updateZ3Intensity(mins);

  highlightZ3Near(mins);
}

/* =================== Listeners =================== */
window.addEventListener("resize", updateTileSize);
document.getElementById("slider").addEventListener("input", async e => {
  const idx = parseInt(e.target.value)||0;
  updateGrid(idx);
document.getElementById("slider").max = csvData.length - 1;

  // D√©tection bord du slider ‚Üí fusion
  const slider = e.target;
  if (idx <= 0 && !isMerging) {
    console.log("üïí Maintien confirm√© ‚Üí chargement du jour pr√©c√©dent");
    await mergeNeighborDay(-1); // jour pr√©c√©dent
  } else if (idx >= slider.max && !isMerging) {
    console.log("üïí Maintien confirm√© ‚Üí chargement du jour suivant");
    await mergeNeighborDay(1); // jour suivant
  }
});

document.getElementById("minInput").addEventListener("change", ()=>{
  const v=parseFloat(document.getElementById("minInput").value);
  localStorage.setItem("scaleMin", isFinite(v)?String(v):"30");
  if(csvData.length) updateGrid(parseInt(document.getElementById("slider").value)||0);
});
document.getElementById("maxInput").addEventListener("change", ()=>{
  const v=parseFloat(document.getElementById("maxInput").value);
  localStorage.setItem("scaleMax", isFinite(v)?String(v):"60");
  if(csvData.length) updateGrid(parseInt(document.getElementById("slider").value)||0);
});



/* =================== INIT =================== */

  /* ----------- Th√®mes + persistance ----------- */
function setTheme(theme){
  const r=document.documentElement;
  localStorage.setItem("selectedTheme",theme);

  if(theme==="orange"){
    r.style.setProperty("--accent","#ff7043");
    r.style.setProperty("--accent-darker","#e64a19");
    r.style.setProperty("--accent-muted","#ffccbc");
    r.style.setProperty("--bg","#fff5f5");
    r.style.setProperty("--panel","#ffffff");
    r.style.setProperty("--sidebar-bg","#ffe5d9");
    r.style.setProperty("--danger","#d84315");
    r.style.setProperty("--text","#333");
    r.style.setProperty("--row-even","#ffe5d9");
    r.style.setProperty("--row-odd","#fff5f5");
    r.style.setProperty("--text-light", "#fff");
r.style.setProperty("--text-dark", "#222");

  }
  if(theme==="blue"){
    r.style.setProperty("--accent","#2196f3");
    r.style.setProperty("--accent-darker","#1976d2");
    r.style.setProperty("--accent-muted","#bbdefb");
    r.style.setProperty("--bg","#e3f2fd");
    r.style.setProperty("--panel","#ffffff");
    r.style.setProperty("--sidebar-bg","#bbdefb");
    r.style.setProperty("--danger","#0d47a1");
    r.style.setProperty("--text","#0d47a1");
    r.style.setProperty("--row-even","#bbdefb");
    r.style.setProperty("--row-odd","#e3f2fd");
    r.style.setProperty("--text-light", "#fff");
r.style.setProperty("--text-dark", "#222");

  }
  if(theme==="green"){
    r.style.setProperty("--accent","#4caf50");
    r.style.setProperty("--accent-darker","#2e7d32");
    r.style.setProperty("--accent-muted","#c8e6c9");
    r.style.setProperty("--bg","#f1f8e9");
    r.style.setProperty("--panel","#ffffff");
    r.style.setProperty("--sidebar-bg","#c8e6c9");
    r.style.setProperty("--danger","#1b5e20");
    r.style.setProperty("--text","#1b5e20");
    r.style.setProperty("--row-even","#c8e6c9");
    r.style.setProperty("--row-odd","#f1f8e9");
    r.style.setProperty("--text-light", "#fff");
r.style.setProperty("--text-dark", "#222");

  }
  if(theme==="purple"){
    r.style.setProperty("--accent","#9c27b0");
    r.style.setProperty("--accent-darker","#6a1b9a");
    r.style.setProperty("--accent-muted","#e1bee7");
    r.style.setProperty("--bg","#f3e5f5");
    r.style.setProperty("--panel","#ffffff");
    r.style.setProperty("--sidebar-bg","#e1bee7");
    r.style.setProperty("--danger","#4a148c");
    r.style.setProperty("--text","#4a148c");
    r.style.setProperty("--row-even","#e1bee7");
    r.style.setProperty("--row-odd","#f3e5f5");
    r.style.setProperty("--text-light", "#fff");
r.style.setProperty("--text-dark", "#222");

  }
  if(theme==="bordeaux"){
    r.style.setProperty("--accent","#800020");
    r.style.setProperty("--accent-darker","#4b0014");
    r.style.setProperty("--accent-muted","#d7a1a9");
    r.style.setProperty("--bg","#fff0f2");
    r.style.setProperty("--panel","#ffffff");
    r.style.setProperty("--sidebar-bg","#f3cdd3");
    r.style.setProperty("--danger","#600018");
    r.style.setProperty("--text","#4b0014");
    r.style.setProperty("--row-even","#f3cdd3");
    r.style.setProperty("--row-odd","#fff0f2");
    r.style.setProperty("--text-light", "#fff");
r.style.setProperty("--text-dark", "#222");

  }

  r.style.setProperty("--text-light", "#fff");
  r.style.setProperty("--text-dark", "#222");

}

  const savedTheme = localStorage.getItem("selectedTheme") || "orange";
setTheme(savedTheme);


  
document.addEventListener("DOMContentLoaded", async () => {
  await ensureZ3FilesLoaded();
  loadPlan();
  requestAnimationFrame(updateTileSize);
  loadCSV();
  window.addEventListener("load", updateTileSize);
});

async function mergeNeighborDay(offset) {
  if (!currentDay || isMerging) return;
  isMerging = true;

// üîπ Utilise le dernier jour fusionn√© comme r√©f√©rence
let refDay = [...mergedDays].sort().pop() || currentDay;
const y = parseInt(refDay.slice(0,4));
const m = parseInt(refDay.slice(4,6))-1;
const d = parseInt(refDay.slice(6,8));
const base = new Date(y,m,d);
base.setDate(base.getDate()+offset);
const nextDay = base.toISOString().slice(0,10).replace(/-/g,"");


  if (mergedDays.has(nextDay)) {
    console.log("‚ö†Ô∏è Jour d√©j√† fusionn√© :", nextDay);
    isMerging = false;
    return;
  }

  console.log(`‚è≥ Chargement du fichier voisin SA00001_${nextDay}.csv...`);
  const list = JSON.parse(localStorage.getItem("csvFilesList")||"[]");
  const neighbor = list.find(f => f.name.includes(nextDay));
  if (!neighbor) {
    console.warn("‚ö†Ô∏è Aucun fichier voisin trouv√© pour", nextDay);
    isMerging = false;
    return;
  }

    try {
    const url = `https://smes21540.netlify.app/.netlify/functions/drive?id=${neighbor.id}&name=${encodeURIComponent(neighbor.name)}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error("Erreur proxy Drive");
    const buf = await res.arrayBuffer();
    const text = decodeSmart(buf);
    const parsed = Papa.parse(text,{header:true,skipEmptyLines:true});
    const data = parsed.data||[];

    csvData = csvData.concat(data);
    document.getElementById("slider").max = csvData.length-1;
    mergedDays.add(nextDay);

    console.log(`‚úÖ Fichier fusionn√© : ${neighbor.name} (${data.length} lignes)`);
    console.log(`üìä Fusion r√©ussie ‚Üí ${csvData.length} lignes au total`);
    console.log(`üîç Recherche Z3 du voisin ${nextDay} ‚Üí`);
    await mergeZ3ForDay(nextDay);

// üîÅ === RECHARGEMENT COMPLET APR√àS FUSION MULTI-JOURS ===
console.log("‚ôªÔ∏è Rafra√Æchissement complet : reconstruction compl√®te de la page");
buildGrid();              // Recr√©e toute la grille (haut + bas)
addSpecialsAfterCSV();    // R√©injecte les cases sp√©ciales
updateGrid(lastSliderIndex);  // Affiche la derni√®re ligne active fusionn√©e
renderZ3List();           // Reconstruit le panneau d‚Äô√©v√©nements Z3
highlightZ3Near(currentRowMinutes(lastSliderIndex)); // Surligne √©v√©nement le plus proche
updateTileSize();         // Recalcule la taille responsive


  } catch(err) {
    console.error("‚ùå Erreur fusion jour", err);
  }

  isMerging = false;

}
// üü¢ Fonction d√©plac√©e ici (√† l‚Äôext√©rieur)
async function mergeZ3ForDay(dayStr) {
  const z3Files = await ensureZ3FilesLoaded();
  const sameDay = z3Files.filter(f => f.name.includes(dayStr));
  if (!sameDay.length) {
    console.log(`‚ö†Ô∏è Aucun fichier Z3 trouv√© pour ${dayStr}`);
    return;
  }

  for (const f of sameDay) {
    try {
      console.log("üåê T√©l√©chargement Z3 voisin :", f.name);
      const url = `https://smes21540.netlify.app/.netlify/functions/drive?id=${f.id}&name=${encodeURIComponent(f.name || "")}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Erreur proxy Drive");
      const buf = await res.arrayBuffer();
      const text = decodeSmart(buf);
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
      const startIndex = lines.findIndex(l => /trigger.?time|horodatage/i.test(l));
      const csvClean = lines.slice(startIndex >= 0 ? startIndex : 0).join("\n");
      const parsed = Papa.parse(csvClean, { header: true, skipEmptyLines: true });

      const H = parsed.meta.fields || [];
      const rows = parsed.data || [];

      const timeCol = H.find(h => /(trigger.?time|heure|horodatage|time|temps)/i.test(h)) || H[0];
      const msgCol  = H.find(h => /(message|desc|description|evenement|event)/i.test(h)) || H[1];
      const addrCol = H.find(h => /(address|adresse|addr|zone|address ?1)/i.test(h)) || null;

      for (const r of rows) {
        const t = String(r[timeCol] || "").trim();
        const msg = String(r[msgCol] || "").trim();
        const addr = String(r[addrCol] || "").trim();
        const mins = toMinutes(t);
        if (!isNaN(mins) && msg) {
          z3Events.push({
            timeText: t,
            minutes: mins,
            desc: addr ? `${msg} (${addr})` : msg,
            fileId: f.id,
            fileName: f.name,
          });
        }
      }
    } catch (err) {
      console.error("‚ùå Erreur fusion Z3 du voisin :", f.name, err);
    }
  }

  console.log(`‚úÖ Fusion des √©v√©nements Z3 du jour ${dayStr} termin√©e (${sameDay.length} fichier(s)).`);
  z3Events.sort((a, b) => a.minutes - b.minutes);
  renderZ3List();
}



</script>
</body>
</html>











